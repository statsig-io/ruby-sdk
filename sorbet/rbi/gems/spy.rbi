# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/spy/all/spy.rbi
#
# spy-1.0.3

module Spy
  def self.create_and_hook_spy(base_object, method_name, singleton_method = nil); end
  def self.get(base_object, *method_names); end
  def self.get_const(base_module, *constant_names); end
  def self.mock(klass, *stubs); end
  def self.mock_all(klass, *stubs); end
  def self.off(base_object, *method_names); end
  def self.off_const(base_module, *constant_names); end
  def self.off_instance_method(base_class, *method_names); end
  def self.on(base_object, *method_names); end
  def self.on_const(base_module, *constant_names); end
  def self.on_instance_method(base_class, *method_names); end
  def self.teardown; end
end
class Spy::Error < StandardError
end
class Spy::AlreadyStubbedError < Spy::Error
end
class Spy::AlreadyHookedError < Spy::Error
end
class Spy::NotHookedError < Spy::Error
end
class Spy::NeverHookedError < Spy::Error
end
class Spy::NoSpyError < Spy::Error
end
module Marshal
  def self.dump_with_mocks(*args); end
  def self.dump_without_mocks(*arg0); end
end
class Spy::Agency
  def active?(spy); end
  def check_spy!(spy); end
  def clear!; end
  def dissolve!; end
  def find(id); end
  def initialize; end
  def recruit(spy); end
  def retire(spy); end
  def self.allocate; end
  def self.new(*arg0, **); end
  def spies; end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module Spy::API
  def assert_received(base_object, method_name); end
  def assert_received_with(base_object, method_name, *args, &block); end
  def have_received(method_name); end
end
class Spy::API::DidNotReceiveError < Spy::Error
end
class Spy::API::HaveReceived
  def actual; end
  def args_message; end
  def description; end
  def failure_message_for_should; end
  def failure_message_for_should_not; end
  def initialize(method_name); end
  def matches?(actual); end
  def method_name; end
  def spy; end
  def with(*args, &block); end
end
module Spy::Base
end
class Spy::CallLog
  def args; end
  def block; end
  def called_from; end
  def initialize(object, called_from, args, block, result); end
  def object; end
  def result; end
end
class Spy::Constant
  def and_hide; end
  def and_return(value); end
  def base_module; end
  def constant_name; end
  def currently_defined?; end
  def hidden?; end
  def hook(opts = nil); end
  def hooked?; end
  def initialize(base_module, constant_name); end
  def name; end
  def original_value; end
  def previously_defined?; end
  def self.get(base_module, constant_name); end
  def self.off(base_module, constant_name); end
  def self.on(base_module, constant_name); end
  def unhook; end
  include Spy::Base
end
module Spy::Mock
  def initialize(&mock_method); end
  def instance_of?(other); end
  def method(method_name); end
  def self.args_for_method(method); end
  def self.classes_to_override_methods(mod); end
  def self.get_inherited_methods(klass_ancestors, visibility); end
  def self.included(mod); end
  def self.new(klass); end
  include Spy::Base
end
class Spy::Nest
  def add(spy); end
  def base_module; end
  def get(constant_name); end
  def hooked?(constant_name); end
  def hooked_constants; end
  def initialize(base_module); end
  def remove(spy); end
  def self.all; end
  def self.fetch(base_module); end
  def self.get(base_module); end
end
class Spy::Subroutine
  def and_call_through; end
  def and_raise(exception = nil, message = nil); end
  def and_return(value = nil, &block); end
  def and_throw(*args); end
  def and_yield(*args); end
  def arity_range; end
  def base_object; end
  def build_call_through_plan(object); end
  def call_plan(plan, block, *args); end
  def calls; end
  def check_arity!(arity); end
  def check_for_too_many_arguments!(block); end
  def clear_method!; end
  def current_method; end
  def has_been_called?; end
  def has_been_called_with?(*args, &block); end
  def hook(opts = nil); end
  def hook_opts; end
  def hooked?; end
  def initialize(object, method_name, singleton_method = nil); end
  def invoke(object, args, block, called_from); end
  def method_name; end
  def method_owner; end
  def method_visibility_of(method_name, all = nil); end
  def original_method; end
  def original_method_visibility; end
  def override_method; end
  def reset!; end
  def ruby_27_last_arg_hash?(args); end
  def self.get(base_object, method_name, singleton_method = nil); end
  def self.get_spies(base_object, singleton_methods = nil); end
  def self.get_spy_id(method); end
  def self.off(base_object, method_name, singleton_method = nil); end
  def self.on(base_object, method_name, singleton_method = nil); end
  def singleton_method; end
  def unhook; end
  include Spy::Base
end
